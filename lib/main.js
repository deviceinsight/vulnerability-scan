const chalk = require('chalk');
const { exec } = require('child_process');
const yargs = require('yargs');
const { table } = require('table');
const fs = require('fs');

const { mapSeverityToColor, parseJson } = require('./utils');

const { argv } = yargs
	.config('config')
	.options({
		a: {
			alias: 'advisories',
			default: [],
			describe: 'Whitelisted advisory ids',
			type: 'array'
		},
		ad: {
			alias: '__advisories',
			default: '',
			describe: 'Whitelisted advisory reasons'
		},
		p: {
			alias: 'pretty-print',
			default: false,
			describe: 'If set, pretty prints the logged output'
		},
		r: {
			alias: 'registry',
			default: undefined,
			describe: 'The registry to resolve packages by name and version'
		},
		s: {
			alias: 'severity',
			default: 'moderate',
			describe: 'Exit level of set severity vulnerabilities or higher',
			choices: ['low', 'moderate', 'high', 'critical']
		},
		w: {
			alias: 'whitelist',
			default: [],
			describe: 'Whitelisted module names',
			type: 'array'
		},
		wd: {
			alias: '__whitelist',
			default: '',
			describe: 'Whitelisted module reasons'
		}
	})
	.help('help');

const advisories = argv.a.length > 0 ? `-a ${argv.a.join(' ')}` : '';
const advisoryReasons =
	!!argv.ad &&
	argv.a.length &&
	Object.keys(argv.ad)
		.map(a => ({ a, r: argv.ad[a] }))
		.filter(Boolean);
const hasLogs = argv.l;
const isPretty = argv.p;
const registry = argv.r && `--registry ${argv.r}`;
const severity = `--${argv.s}`;
const showNotFound = `--show-not-found=false`;
const whitelist = argv.w.length > 0 ? `-w ${argv.w.join(' ')}` : '';
const whitelistReasons =
	!!argv.wd &&
	argv.w.length &&
	Object.keys(argv.wd)
		.map(w => ({ w, r: argv.wd[w] }))
		.filter(Boolean);

const audit = exec(`audit-ci ${severity} ${advisories} ${whitelist} ${showNotFound} ${registry}`);

let tableData = [];
let errorData = [];

audit.stdout.on('data', data => {
	const parsedData = parseJson(data.toString('utf8'));
	if (isPretty) {
		const { advisory, resolution } = parsedData;
		if (advisory && resolution) {
			const advisoryData = [
				[chalk`{${mapSeverityToColor(advisory.severity)} ${advisory.severity} }`, advisory.title],
				['Package', advisory.module_name],
				['Path', resolution.path.split('>').join(' > ')],
				['Patched in', advisory.patched_versions],
				['More info', advisory.url]
			];
			tableData.push(advisoryData);
		}
	} else {
		if (parsedData) {
			console.log(data.toString('utf8'), '\n');
		}
	}
});

audit.stderr.on('data', data => {
	const parsedData = data.toString('utf8');
	if (isPretty) {
		errorData.push([parsedData]);
	} else {
		console.log(parsedData);
	}
});

audit.on('close', code => {
	if (isPretty) {
		const { dataTableConfig, errorTableConfig } = require('./utils');
		tableData.forEach(tableToRender => {
			console.log(table(tableToRender, dataTableConfig));
		});
		if (errorData.length > 0) {
			console.log(table(errorData, errorTableConfig));
		}
	}

	advisoryReasons &&
		advisoryReasons.length &&
		console.log(
			chalk`{yellow These are the provided descriptions on why the advisories have been whitelisted:\n}`,
			...advisoryReasons.map(({ a, r }) => `${a}: ${r}\n`)
		);

	whitelistReasons &&
		whitelistReasons.length &&
		console.log(
			chalk`{yellow These are the provided descriptions on why the modules have been whitelisted:\n}`,
			...whitelistReasons.map(({ w, r }) => `${w}: ${r}\n`)
		);

	if (code === 0) {
		console.log(chalk`{green ✔ Passed the security audit.\n}`);
	} else {
		console.log(chalk`{red ✘ Please resolve the existing vulnerabilities.\n}`);
		process.exit(1);
	}
});
